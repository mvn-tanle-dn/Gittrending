{"ast":null,"code":"var _defineProperty = require(\"/Users/minmin/Documents/TuongTacMayTinh-Client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _require = require('redux-persist'),\n    createTransform = _require.createTransform;\n/**\n * Transforms state on its way to being serialized and persisted\n * @param inboundState\n * @param config\n * @return {*}\n */\n\n\nvar transformPersistence = function transformPersistence(inboundState, config) {\n  inboundState = inboundState || {}; // If autoExpire is required i.e. user won't be setting the time\n  // then on each update change the `persistedAt` to be current time\n  // so that the rehydrater will pick it up based on this time if\n  // the record is not updated for some time\n\n  if (config.autoExpire && !inboundState[config.persistedAtKey]) {\n    inboundState = Object.assign({}, inboundState, _defineProperty({}, config.persistedAtKey, new Date().getTime()));\n  }\n\n  return inboundState;\n};\n/**\n * Transform state being rehydrated\n * @param outboundState\n * @param config\n * @return {*}\n */\n\n\nvar transformRehydrate = function transformRehydrate(outboundState, config) {\n  outboundState = outboundState || {}; // Check for the possible expiry if state has the persisted date\n\n  if (config.expireSeconds && outboundState[config.persistedAtKey]) {\n    var startTime = new Date(outboundState[config.persistedAtKey]).getTime();\n    var endTime = new Date().getTime();\n    var duration = endTime - startTime;\n    var seconds = duration / 1000; // If the state is older than the set expiry time,\n    // reset it to initial state\n\n    if (seconds > config.expireSeconds) {\n      return Object.assign({}, config.expiredState);\n    }\n  }\n\n  return outboundState;\n};\n/**\n * Creates transform object with the given expiry configuration\n * @param reducerKey\n * @param config\n * @return {Transform<{}, any>}\n */\n\n\nfunction expireReducer(reducerKey) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var defaults = {\n    // Key to be used for the time relative to which store is to be expired\n    persistedAtKey: '__persisted_at',\n    // Seconds after which store will be expired\n    expireSeconds: null,\n    // State to be used for resetting e.g. provide initial reducer state\n    expiredState: {},\n    // Use it if you don't want to manually set the time and want the store to\n    // be automatically expired if the record is not updated in the `expireSeconds` time\n    autoExpire: false\n  };\n  config = Object.assign({}, defaults, config);\n  return createTransform( // transform state on its way to being serialized and persisted.\n  function (inboundState) {\n    return transformPersistence(inboundState, config);\n  }, // transform state being rehydrated\n  function (outboundState) {\n    return transformRehydrate(outboundState, config);\n  }, // define which reducers this transform gets called for.\n  {\n    whitelist: [reducerKey]\n  });\n}\n\nmodule.exports = expireReducer;","map":{"version":3,"sources":["/Users/minmin/Documents/TuongTacMayTinh-Client/node_modules/redux-persist-expire/index.js"],"names":["require","createTransform","transformPersistence","inboundState","config","autoExpire","persistedAtKey","Object","assign","Date","getTime","transformRehydrate","outboundState","expireSeconds","startTime","endTime","duration","seconds","expiredState","expireReducer","reducerKey","defaults","whitelist","module","exports"],"mappings":";;AAAA,eAA4BA,OAAO,CAAC,eAAD,CAAnC;AAAA,IAAQC,eAAR,YAAQA,eAAR;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMC,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACC,YAAD,EAAeC,MAAf,EAA0B;AACrDD,EAAAA,YAAY,GAAGA,YAAY,IAAI,EAA/B,CADqD,CAGrD;AACA;AACA;AACA;;AACA,MAAIC,MAAM,CAACC,UAAP,IAAqB,CAACF,YAAY,CAACC,MAAM,CAACE,cAAR,CAAtC,EAA+D;AAC7DH,IAAAA,YAAY,GAAGI,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,YAAlB,sBACZC,MAAM,CAACE,cADK,EACa,IAAIG,IAAJ,EAAD,CAAaC,OAAb,EADZ,EAAf;AAGD;;AAED,SAAOP,YAAP;AACD,CAdD;AAgBA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMQ,kBAAkB,GAAG,SAArBA,kBAAqB,CAACC,aAAD,EAAgBR,MAAhB,EAA2B;AACpDQ,EAAAA,aAAa,GAAGA,aAAa,IAAI,EAAjC,CADoD,CAGpD;;AACA,MAAIR,MAAM,CAACS,aAAP,IAAwBD,aAAa,CAACR,MAAM,CAACE,cAAR,CAAzC,EAAkE;AAChE,QAAMQ,SAAS,GAAI,IAAIL,IAAJ,CAASG,aAAa,CAACR,MAAM,CAACE,cAAR,CAAtB,CAAD,CAAiDI,OAAjD,EAAlB;AACA,QAAMK,OAAO,GAAI,IAAIN,IAAJ,EAAD,CAAaC,OAAb,EAAhB;AAEA,QAAMM,QAAQ,GAAGD,OAAO,GAAGD,SAA3B;AACA,QAAMG,OAAO,GAAGD,QAAQ,GAAG,IAA3B,CALgE,CAOhE;AACA;;AACA,QAAIC,OAAO,GAAGb,MAAM,CAACS,aAArB,EAAoC;AAClC,aAAON,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBJ,MAAM,CAACc,YAAzB,CAAP;AACD;AACF;;AAED,SAAON,aAAP;AACD,CAnBD;AAqBA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASO,aAAT,CAAuBC,UAAvB,EAAgD;AAAA,MAAbhB,MAAa,uEAAJ,EAAI;AAE9C,MAAMiB,QAAQ,GAAG;AACf;AACAf,IAAAA,cAAc,EAAE,gBAFD;AAGf;AACAO,IAAAA,aAAa,EAAE,IAJA;AAKf;AACAK,IAAAA,YAAY,EAAE,EANC;AAOf;AACA;AACAb,IAAAA,UAAU,EAAE;AATG,GAAjB;AAYAD,EAAAA,MAAM,GAAGG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBa,QAAlB,EAA4BjB,MAA5B,CAAT;AAEA,SAAOH,eAAe,EACpB;AACA,YAACE,YAAD;AAAA,WAAkBD,oBAAoB,CAACC,YAAD,EAAeC,MAAf,CAAtC;AAAA,GAFoB,EAGpB;AACA,YAACQ,aAAD;AAAA,WAAmBD,kBAAkB,CAACC,aAAD,EAAgBR,MAAhB,CAArC;AAAA,GAJoB,EAKpB;AACA;AACEkB,IAAAA,SAAS,EAAE,CAACF,UAAD;AADb,GANoB,CAAtB;AAUD;;AAEDG,MAAM,CAACC,OAAP,GAAiBL,aAAjB","sourcesContent":["const { createTransform } = require('redux-persist');\n\n/**\n * Transforms state on its way to being serialized and persisted\n * @param inboundState\n * @param config\n * @return {*}\n */\nconst transformPersistence = (inboundState, config) => {\n  inboundState = inboundState || {};\n\n  // If autoExpire is required i.e. user won't be setting the time\n  // then on each update change the `persistedAt` to be current time\n  // so that the rehydrater will pick it up based on this time if\n  // the record is not updated for some time\n  if (config.autoExpire && !inboundState[config.persistedAtKey]) {\n    inboundState = Object.assign({}, inboundState, {\n      [config.persistedAtKey]: (new Date()).getTime()\n    });\n  }\n\n  return inboundState;\n};\n\n/**\n * Transform state being rehydrated\n * @param outboundState\n * @param config\n * @return {*}\n */\nconst transformRehydrate = (outboundState, config) => {\n  outboundState = outboundState || {};\n\n  // Check for the possible expiry if state has the persisted date\n  if (config.expireSeconds && outboundState[config.persistedAtKey]) {\n    const startTime = (new Date(outboundState[config.persistedAtKey])).getTime();\n    const endTime = (new Date()).getTime();\n\n    const duration = endTime - startTime;\n    const seconds = duration / 1000;\n\n    // If the state is older than the set expiry time,\n    // reset it to initial state\n    if (seconds > config.expireSeconds) {\n      return Object.assign({}, config.expiredState);\n    }\n  }\n\n  return outboundState;\n};\n\n/**\n * Creates transform object with the given expiry configuration\n * @param reducerKey\n * @param config\n * @return {Transform<{}, any>}\n */\nfunction expireReducer(reducerKey, config = {}) {\n\n  const defaults = {\n    // Key to be used for the time relative to which store is to be expired\n    persistedAtKey: '__persisted_at',\n    // Seconds after which store will be expired\n    expireSeconds: null,\n    // State to be used for resetting e.g. provide initial reducer state\n    expiredState: {},\n    // Use it if you don't want to manually set the time and want the store to\n    // be automatically expired if the record is not updated in the `expireSeconds` time\n    autoExpire: false\n  };\n\n  config = Object.assign({}, defaults, config);\n\n  return createTransform(\n    // transform state on its way to being serialized and persisted.\n    (inboundState) => transformPersistence(inboundState, config),\n    // transform state being rehydrated\n    (outboundState) => transformRehydrate(outboundState, config),\n    // define which reducers this transform gets called for.\n    {\n      whitelist: [reducerKey]\n    }\n  );\n}\n\nmodule.exports = expireReducer;\n"]},"metadata":{},"sourceType":"script"}